// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type AwsInitParameters struct {

	// (String) Amazon Machine Image to use
	// Amazon Machine Image to use. Will be defaulted to an AMI of your selected operating system and region
	AMI *string `json:"ami,omitempty" tf:"ami,omitempty"`

	// (Boolean) Flag which controls a property of the AWS instance
	// Flag which controls a property of the AWS instance. When set the AWS instance will get a public IP address assigned during launch overriding a possible setting in the used AWS subnet.
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// (String) Availability zone in which to place the node
	// Availability zone in which to place the node. It is coupled with the subnet to which the node will belong
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// (Number) Size of the volume in GBs
	// Size of the volume in GBs. Only one volume will be created
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// (String) EC2 instance type
	// EC2 instance type
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// (String) The VPC subnet to which the node shall be connected
	// The VPC subnet to which the node shall be connected
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// (Map of String) Additional instance tags
	// Additional instance tags
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// (String) EBS volume type
	// EBS volume type
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type AwsObservation struct {

	// (String) Amazon Machine Image to use
	// Amazon Machine Image to use. Will be defaulted to an AMI of your selected operating system and region
	AMI *string `json:"ami,omitempty" tf:"ami,omitempty"`

	// (Boolean) Flag which controls a property of the AWS instance
	// Flag which controls a property of the AWS instance. When set the AWS instance will get a public IP address assigned during launch overriding a possible setting in the used AWS subnet.
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// (String) Availability zone in which to place the node
	// Availability zone in which to place the node. It is coupled with the subnet to which the node will belong
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// (Number) Size of the volume in GBs
	// Size of the volume in GBs. Only one volume will be created
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// (String) EC2 instance type
	// EC2 instance type
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// (String) The VPC subnet to which the node shall be connected
	// The VPC subnet to which the node shall be connected
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// (Map of String) Additional instance tags
	// Additional instance tags
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// (String) EBS volume type
	// EBS volume type
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type AwsParameters struct {

	// (String) Amazon Machine Image to use
	// Amazon Machine Image to use. Will be defaulted to an AMI of your selected operating system and region
	// +kubebuilder:validation:Optional
	AMI *string `json:"ami,omitempty" tf:"ami,omitempty"`

	// (Boolean) Flag which controls a property of the AWS instance
	// Flag which controls a property of the AWS instance. When set the AWS instance will get a public IP address assigned during launch overriding a possible setting in the used AWS subnet.
	// +kubebuilder:validation:Optional
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// (String) Availability zone in which to place the node
	// Availability zone in which to place the node. It is coupled with the subnet to which the node will belong
	// +kubebuilder:validation:Optional
	AvailabilityZone *string `json:"availabilityZone" tf:"availability_zone,omitempty"`

	// (Number) Size of the volume in GBs
	// Size of the volume in GBs. Only one volume will be created
	// +kubebuilder:validation:Optional
	DiskSize *float64 `json:"diskSize" tf:"disk_size,omitempty"`

	// (String) EC2 instance type
	// EC2 instance type
	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType" tf:"instance_type,omitempty"`

	// (String) The VPC subnet to which the node shall be connected
	// The VPC subnet to which the node shall be connected
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`

	// (Map of String) Additional instance tags
	// Additional instance tags
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// (String) EBS volume type
	// EBS volume type
	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType" tf:"volume_type,omitempty"`
}

type AzureInitParameters struct {

	// (Boolean) Flag which controls a property of the AWS instance
	// whether to have public facing IP or not
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// Data disk size in GB
	DiskSizeGb *float64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`

	// (String)
	// Node image id
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// OS disk size in GB
	OsDiskSizeGb *float64 `json:"osDiskSizeGb,omitempty" tf:"os_disk_size_gb,omitempty"`

	// (String) VM size
	// VM size
	Size *string `json:"size,omitempty" tf:"size,omitempty"`

	// (Map of String) Additional instance tags
	// Additional metadata to set
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Represents the availablity zones for azure vms
	Zones []*string `json:"zones,omitempty" tf:"zones,omitempty"`
}

type AzureObservation struct {

	// (Boolean) Flag which controls a property of the AWS instance
	// whether to have public facing IP or not
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// Data disk size in GB
	DiskSizeGb *float64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`

	// (String)
	// Node image id
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// OS disk size in GB
	OsDiskSizeGb *float64 `json:"osDiskSizeGb,omitempty" tf:"os_disk_size_gb,omitempty"`

	// (String) VM size
	// VM size
	Size *string `json:"size,omitempty" tf:"size,omitempty"`

	// (Map of String) Additional instance tags
	// Additional metadata to set
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Represents the availablity zones for azure vms
	Zones []*string `json:"zones,omitempty" tf:"zones,omitempty"`
}

type AzureParameters struct {

	// (Boolean) Flag which controls a property of the AWS instance
	// whether to have public facing IP or not
	// +kubebuilder:validation:Optional
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// Data disk size in GB
	// +kubebuilder:validation:Optional
	DiskSizeGb *float64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`

	// (String)
	// Node image id
	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// OS disk size in GB
	// +kubebuilder:validation:Optional
	OsDiskSizeGb *float64 `json:"osDiskSizeGb,omitempty" tf:"os_disk_size_gb,omitempty"`

	// (String) VM size
	// VM size
	// +kubebuilder:validation:Optional
	Size *string `json:"size" tf:"size,omitempty"`

	// (Map of String) Additional instance tags
	// Additional metadata to set
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Represents the availablity zones for azure vms
	// +kubebuilder:validation:Optional
	Zones []*string `json:"zones,omitempty" tf:"zones,omitempty"`
}

type CloudInitParameters struct {

	// AWS node deployment specification
	Aws []AwsInitParameters `json:"aws,omitempty" tf:"aws,omitempty"`

	// Azure node deployment specification
	Azure []AzureInitParameters `json:"azure,omitempty" tf:"azure,omitempty"`

	// OpenStack node deployment specification
	Openstack []OpenstackInitParameters `json:"openstack,omitempty" tf:"openstack,omitempty"`
}

type CloudObservation struct {

	// AWS node deployment specification
	Aws []AwsObservation `json:"aws,omitempty" tf:"aws,omitempty"`

	// Azure node deployment specification
	Azure []AzureObservation `json:"azure,omitempty" tf:"azure,omitempty"`

	// OpenStack node deployment specification
	Openstack []OpenstackObservation `json:"openstack,omitempty" tf:"openstack,omitempty"`
}

type CloudParameters struct {

	// AWS node deployment specification
	// +kubebuilder:validation:Optional
	Aws []AwsParameters `json:"aws,omitempty" tf:"aws,omitempty"`

	// Azure node deployment specification
	// +kubebuilder:validation:Optional
	Azure []AzureParameters `json:"azure,omitempty" tf:"azure,omitempty"`

	// OpenStack node deployment specification
	// +kubebuilder:validation:Optional
	Openstack []OpenstackParameters `json:"openstack,omitempty" tf:"openstack,omitempty"`
}

type DeploymentInitParameters struct {

	// Node deployment specification
	Spec []SpecInitParameters `json:"spec,omitempty" tf:"spec,omitempty"`
}

type DeploymentObservation struct {

	// (String) Cluster that node deployment belongs to
	// Cluster that node deployment belongs to
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// (String) Creation timestamp
	// Creation timestamp
	CreationTimestamp *string `json:"creationTimestamp,omitempty" tf:"creation_timestamp,omitempty"`

	// (String) Deletion timestamp
	// Deletion timestamp
	DeletionTimestamp *string `json:"deletionTimestamp,omitempty" tf:"deletion_timestamp,omitempty"`

	// (String)
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Project the cluster belongs to
	// Project the cluster belongs to
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Node deployment specification
	Spec []SpecObservation `json:"spec,omitempty" tf:"spec,omitempty"`
}

type DeploymentParameters struct {

	// (String) Cluster that node deployment belongs to
	// Cluster that node deployment belongs to
	// +kubebuilder:validation:Required
	ClusterID *string `json:"clusterId" tf:"cluster_id,omitempty"`

	// (String) Project the cluster belongs to
	// Project the cluster belongs to
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Node deployment specification
	// +kubebuilder:validation:Optional
	Spec []SpecParameters `json:"spec,omitempty" tf:"spec,omitempty"`
}

type FlatcarInitParameters struct {

	// (Boolean) Disable flatcar auto update feature
	// Disable flatcar auto update feature
	DisableAutoUpdate *bool `json:"disableAutoUpdate,omitempty" tf:"disable_auto_update,omitempty"`
}

type FlatcarObservation struct {

	// (Boolean) Disable flatcar auto update feature
	// Disable flatcar auto update feature
	DisableAutoUpdate *bool `json:"disableAutoUpdate,omitempty" tf:"disable_auto_update,omitempty"`
}

type FlatcarParameters struct {

	// (Boolean) Disable flatcar auto update feature
	// Disable flatcar auto update feature
	// +kubebuilder:validation:Optional
	DisableAutoUpdate *bool `json:"disableAutoUpdate,omitempty" tf:"disable_auto_update,omitempty"`
}

type OpenstackInitParameters struct {

	// (Number) Size of the volume in GBs
	// If set, the rootDisk will be a cinder volume of that size in GiB. If unset, the rootDisk will be ephemeral nova root storage and its size will be derived from the flavor
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// (String) Instance type
	// Instance type
	Flavor *string `json:"flavor,omitempty" tf:"flavor,omitempty"`

	// (String) Image to use
	// Image to use
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// Specifies how often should the controller check if instance is ready before timing out
	InstanceReadyCheckPeriod *string `json:"instanceReadyCheckPeriod,omitempty" tf:"instance_ready_check_period,omitempty"`

	// Specifies how long should the controller check if instance is ready before timing out
	InstanceReadyCheckTimeout *string `json:"instanceReadyCheckTimeout,omitempty" tf:"instance_ready_check_timeout,omitempty"`

	// (String)
	// Specifies the ID of the server group for nodes in the nodes deployment. Defaults to the cluster setting
	ServerGroupID *string `json:"serverGroupId,omitempty" tf:"server_group_id,omitempty"`

	// (Map of String) Additional instance tags
	// Additional instance tags
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// (Boolean) Indicate use of floating ip
	// Indicate use of floating ip in case of floating_ip_pool presense
	UseFloatingIP *bool `json:"useFloatingIp,omitempty" tf:"use_floating_ip,omitempty"`
}

type OpenstackObservation struct {

	// (Number) Size of the volume in GBs
	// If set, the rootDisk will be a cinder volume of that size in GiB. If unset, the rootDisk will be ephemeral nova root storage and its size will be derived from the flavor
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// (String) Instance type
	// Instance type
	Flavor *string `json:"flavor,omitempty" tf:"flavor,omitempty"`

	// (String) Image to use
	// Image to use
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// Specifies how often should the controller check if instance is ready before timing out
	InstanceReadyCheckPeriod *string `json:"instanceReadyCheckPeriod,omitempty" tf:"instance_ready_check_period,omitempty"`

	// Specifies how long should the controller check if instance is ready before timing out
	InstanceReadyCheckTimeout *string `json:"instanceReadyCheckTimeout,omitempty" tf:"instance_ready_check_timeout,omitempty"`

	// (String)
	// Specifies the ID of the server group for nodes in the nodes deployment. Defaults to the cluster setting
	ServerGroupID *string `json:"serverGroupId,omitempty" tf:"server_group_id,omitempty"`

	// (Map of String) Additional instance tags
	// Additional instance tags
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// (Boolean) Indicate use of floating ip
	// Indicate use of floating ip in case of floating_ip_pool presense
	UseFloatingIP *bool `json:"useFloatingIp,omitempty" tf:"use_floating_ip,omitempty"`
}

type OpenstackParameters struct {

	// (Number) Size of the volume in GBs
	// If set, the rootDisk will be a cinder volume of that size in GiB. If unset, the rootDisk will be ephemeral nova root storage and its size will be derived from the flavor
	// +kubebuilder:validation:Optional
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// (String) Instance type
	// Instance type
	// +kubebuilder:validation:Optional
	Flavor *string `json:"flavor" tf:"flavor,omitempty"`

	// (String) Image to use
	// Image to use
	// +kubebuilder:validation:Optional
	Image *string `json:"image" tf:"image,omitempty"`

	// Specifies how often should the controller check if instance is ready before timing out
	// +kubebuilder:validation:Optional
	InstanceReadyCheckPeriod *string `json:"instanceReadyCheckPeriod,omitempty" tf:"instance_ready_check_period,omitempty"`

	// Specifies how long should the controller check if instance is ready before timing out
	// +kubebuilder:validation:Optional
	InstanceReadyCheckTimeout *string `json:"instanceReadyCheckTimeout,omitempty" tf:"instance_ready_check_timeout,omitempty"`

	// (String)
	// Specifies the ID of the server group for nodes in the nodes deployment. Defaults to the cluster setting
	// +kubebuilder:validation:Optional
	ServerGroupID *string `json:"serverGroupId,omitempty" tf:"server_group_id,omitempty"`

	// (Map of String) Additional instance tags
	// Additional instance tags
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// (Boolean) Indicate use of floating ip
	// Indicate use of floating ip in case of floating_ip_pool presense
	// +kubebuilder:validation:Optional
	UseFloatingIP *bool `json:"useFloatingIp,omitempty" tf:"use_floating_ip,omitempty"`
}

type OperatingSystemInitParameters struct {

	// Flatcar operating system
	Flatcar []FlatcarInitParameters `json:"flatcar,omitempty" tf:"flatcar,omitempty"`

	// Ubuntu operating system
	Ubuntu []UbuntuInitParameters `json:"ubuntu,omitempty" tf:"ubuntu,omitempty"`
}

type OperatingSystemObservation struct {

	// Flatcar operating system
	Flatcar []FlatcarObservation `json:"flatcar,omitempty" tf:"flatcar,omitempty"`

	// Ubuntu operating system
	Ubuntu []UbuntuObservation `json:"ubuntu,omitempty" tf:"ubuntu,omitempty"`
}

type OperatingSystemParameters struct {

	// Flatcar operating system
	// +kubebuilder:validation:Optional
	Flatcar []FlatcarParameters `json:"flatcar,omitempty" tf:"flatcar,omitempty"`

	// Ubuntu operating system
	// +kubebuilder:validation:Optional
	Ubuntu []UbuntuParameters `json:"ubuntu,omitempty" tf:"ubuntu,omitempty"`
}

type SpecInitParameters struct {

	// (Number) Maximum number of replicas to scale up
	// Maximum number of replicas to scale up
	MaxReplicas *float64 `json:"maxReplicas,omitempty" tf:"max_replicas,omitempty"`

	// (Number) Minimum number of replicas to downscale
	// Minimum number of replicas to downscale
	MinReplicas *float64 `json:"minReplicas,omitempty" tf:"min_replicas,omitempty"`

	// (Number) Number of replicas
	// Number of replicas
	Replicas *float64 `json:"replicas,omitempty" tf:"replicas,omitempty"`

	// Template specification
	Template []TemplateInitParameters `json:"template,omitempty" tf:"template,omitempty"`
}

type SpecObservation struct {

	// (Number) Maximum number of replicas to scale up
	// Maximum number of replicas to scale up
	MaxReplicas *float64 `json:"maxReplicas,omitempty" tf:"max_replicas,omitempty"`

	// (Number) Minimum number of replicas to downscale
	// Minimum number of replicas to downscale
	MinReplicas *float64 `json:"minReplicas,omitempty" tf:"min_replicas,omitempty"`

	// (Number) Number of replicas
	// Number of replicas
	Replicas *float64 `json:"replicas,omitempty" tf:"replicas,omitempty"`

	// Template specification
	Template []TemplateObservation `json:"template,omitempty" tf:"template,omitempty"`
}

type SpecParameters struct {

	// (Number) Maximum number of replicas to scale up
	// Maximum number of replicas to scale up
	// +kubebuilder:validation:Optional
	MaxReplicas *float64 `json:"maxReplicas,omitempty" tf:"max_replicas,omitempty"`

	// (Number) Minimum number of replicas to downscale
	// Minimum number of replicas to downscale
	// +kubebuilder:validation:Optional
	MinReplicas *float64 `json:"minReplicas,omitempty" tf:"min_replicas,omitempty"`

	// (Number) Number of replicas
	// Number of replicas
	// +kubebuilder:validation:Optional
	Replicas *float64 `json:"replicas,omitempty" tf:"replicas,omitempty"`

	// Template specification
	// +kubebuilder:validation:Optional
	Template []TemplateParameters `json:"template" tf:"template,omitempty"`
}

type TaintsInitParameters struct {

	// (String) Taint effect
	// Taint effect
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// (String) Taint key
	// Taint key
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Taint value
	// Taint value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintsObservation struct {

	// (String) Taint effect
	// Taint effect
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// (String) Taint key
	// Taint key
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Taint value
	// Taint value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintsParameters struct {

	// (String) Taint effect
	// Taint effect
	// +kubebuilder:validation:Optional
	Effect *string `json:"effect" tf:"effect,omitempty"`

	// (String) Taint key
	// Taint key
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (String) Taint value
	// Taint value
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type TemplateInitParameters struct {

	// Cloud specification
	Cloud []CloudInitParameters `json:"cloud,omitempty" tf:"cloud,omitempty"`

	// (Map of String) Map of string keys and values that can be used to organize and categorize objects
	// Map of string keys and values that can be used to organize and categorize (scope and select) objects. It will be applied to Nodes allowing users run their apps on specific Node using labelSelector.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Operating system
	OperatingSystem []OperatingSystemInitParameters `json:"operatingSystem,omitempty" tf:"operating_system,omitempty"`

	// List of taints to set on new nodes
	Taints []TaintsInitParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// Cloud components versions
	Versions []VersionsInitParameters `json:"versions,omitempty" tf:"versions,omitempty"`
}

type TemplateObservation struct {

	// Cloud specification
	Cloud []CloudObservation `json:"cloud,omitempty" tf:"cloud,omitempty"`

	// (Map of String) Map of string keys and values that can be used to organize and categorize objects
	// Map of string keys and values that can be used to organize and categorize (scope and select) objects. It will be applied to Nodes allowing users run their apps on specific Node using labelSelector.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Operating system
	OperatingSystem []OperatingSystemObservation `json:"operatingSystem,omitempty" tf:"operating_system,omitempty"`

	// List of taints to set on new nodes
	Taints []TaintsObservation `json:"taints,omitempty" tf:"taints,omitempty"`

	// Cloud components versions
	Versions []VersionsObservation `json:"versions,omitempty" tf:"versions,omitempty"`
}

type TemplateParameters struct {

	// Cloud specification
	// +kubebuilder:validation:Optional
	Cloud []CloudParameters `json:"cloud" tf:"cloud,omitempty"`

	// (Map of String) Map of string keys and values that can be used to organize and categorize objects
	// Map of string keys and values that can be used to organize and categorize (scope and select) objects. It will be applied to Nodes allowing users run their apps on specific Node using labelSelector.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Operating system
	// +kubebuilder:validation:Optional
	OperatingSystem []OperatingSystemParameters `json:"operatingSystem" tf:"operating_system,omitempty"`

	// List of taints to set on new nodes
	// +kubebuilder:validation:Optional
	Taints []TaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// Cloud components versions
	// +kubebuilder:validation:Optional
	Versions []VersionsParameters `json:"versions,omitempty" tf:"versions,omitempty"`
}

type UbuntuInitParameters struct {

	// (Boolean) Upgrade operating system on boot
	// Upgrade operating system on boot
	DistUpgradeOnBoot *bool `json:"distUpgradeOnBoot,omitempty" tf:"dist_upgrade_on_boot,omitempty"`
}

type UbuntuObservation struct {

	// (Boolean) Upgrade operating system on boot
	// Upgrade operating system on boot
	DistUpgradeOnBoot *bool `json:"distUpgradeOnBoot,omitempty" tf:"dist_upgrade_on_boot,omitempty"`
}

type UbuntuParameters struct {

	// (Boolean) Upgrade operating system on boot
	// Upgrade operating system on boot
	// +kubebuilder:validation:Optional
	DistUpgradeOnBoot *bool `json:"distUpgradeOnBoot,omitempty" tf:"dist_upgrade_on_boot,omitempty"`
}

type VersionsInitParameters struct {

	// (String) Kubelet version
	// Kubelet version
	Kubelet *string `json:"kubelet,omitempty" tf:"kubelet,omitempty"`
}

type VersionsObservation struct {

	// (String) Kubelet version
	// Kubelet version
	Kubelet *string `json:"kubelet,omitempty" tf:"kubelet,omitempty"`
}

type VersionsParameters struct {

	// (String) Kubelet version
	// Kubelet version
	// +kubebuilder:validation:Optional
	Kubelet *string `json:"kubelet,omitempty" tf:"kubelet,omitempty"`
}

// DeploymentSpec defines the desired state of Deployment
type DeploymentSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            DeploymentParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider DeploymentInitParameters `json:"initProvider,omitempty"`
}

// DeploymentStatus defines the observed state of Deployment.
type DeploymentStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DeploymentObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Deployment is the Schema for the Deployments API. Node deployment resource manages worker nodes in a cluster
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,syseleven-metakube}
type Deployment struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.spec) || (has(self.initProvider) && has(self.initProvider.spec))",message="spec.forProvider.spec is a required parameter"
	Spec   DeploymentSpec   `json:"spec"`
	Status DeploymentStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DeploymentList contains a list of Deployments
type DeploymentList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Deployment `json:"items"`
}

// Repository type metadata.
var (
	Deployment_Kind             = "Deployment"
	Deployment_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Deployment_Kind}.String()
	Deployment_KindAPIVersion   = Deployment_Kind + "." + CRDGroupVersion.String()
	Deployment_GroupVersionKind = CRDGroupVersion.WithKind(Deployment_Kind)
)

func init() {
	SchemeBuilder.Register(&Deployment{}, &DeploymentList{})
}
